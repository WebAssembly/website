<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>Features to add after the MVP - WebAssembly 中文网</title>
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
  <meta name="keywords" content="wsam,WebAssembly中国,wsam中文">
  <meta mame="description" content="WebAssembly 中文网是一个依附于WebAssembly官网内容的开源中文社区">
</head>


<body>
  <header class="page-section">
    <div class="container-narrow">
    <div class="site-logo">
    </div>
    <nav class="site-nav">
      <a class="site-nav-item btn" href="/">概述</a>
      <a class="site-nav-item btn" href="/demo/">Demo</a>
      <a class="site-nav-item btn" href="/getting-started/developers-guide/">快速开始</a>
      
      
      <a class="site-nav-item btn" href="/docs/high-level-goals/">文档</a>
      <a class="site-nav-item btn" href="/community/feedback/">社区</a>
      <a class="site-nav-item btn" href="/roadmap/">路线图</a>
      <a class="site-nav-item btn" href="/docs/faq/">FAQ</a>
      <a class="site-nav-item btn" href="https://www.w3ctech.com/category/18">中文交流</a>
    </nav>
    </div>
  </header>
  <section class="banner-update">
    <div class="container-narrow">
      <div class="banner-update-icon"></div>
      <span class="banner-update-date"></span>
      <span>多个浏览器已经达成对初始 WebAssembly 版本的一致意见 <a href="/roadmap/">查看更多</a></span>
    </div>
  </section>
  

<section>
  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-lg-9 col-pop">
        <h1 id="features-to-add-after-the-mvp">Features to add after the MVP</h1>

<p>These are features that make sense in the context of the
<a href="../high-level-goals/">high-level goals</a> of WebAssembly but weren’t part of the
initial <a href="../mvp/">Minimum Viable Product</a> release.</p>

<p><strong>Note:</strong> we are in the process of migrating all post-MVP featues to tracking
issues.</p>

<h2 id="tracking-issues">Tracking Issues</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Tracking issue</th>
      <th>Status</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Specification</td>
      <td><a href="https://github.com/WebAssembly/design/issues/1077">1077</a></td>
      <td>in progress</td>
    </tr>
    <tr>
      <td>Threads</td>
      <td><a href="https://github.com/WebAssembly/design/issues/1073">1073</a></td>
      <td>in progress</td>
    </tr>
    <tr>
      <td>Fixed-width SIMD</td>
      <td><a href="https://github.com/WebAssembly/design/issues/1075">1075</a></td>
      <td>in progress</td>
    </tr>
    <tr>
      <td>Exception handling</td>
      <td><a href="https://github.com/WebAssembly/design/issues/1078">1078</a></td>
      <td>in progress</td>
    </tr>
    <tr>
      <td>Garbage collection</td>
      <td><a href="https://github.com/WebAssembly/design/issues/1079">1079</a></td>
      <td>in progress</td>
    </tr>
  </tbody>
</table>

<h2 id="legacy-future-features">Legacy Future Features</h2>

<p><strong>Note:</strong> these will soon move to tracking issues.</p>

<p><img class="emoji" title=":star:" alt=":star:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2b50.png" height="20" width="20" align="absmiddle"> = Essential features we want to prioritize adding shortly after
the <a href="../mvp/">MVP</a>.</p>

<h2 id="on-deck-for-immediate-design">On Deck for Immediate Design</h2>

<h3 id="great-tooling-support">Great tooling support</h3>
<h4 id="star-star-star">
<img class="emoji" title=":star:" alt=":star:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2b50.png" height="20" width="20" align="absmiddle"> <img class="emoji" title=":star:" alt=":star:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2b50.png" height="20" width="20" align="absmiddle"> <img class="emoji" title=":star:" alt=":star:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2b50.png" height="20" width="20" align="absmiddle">
</h4>

<p>This is covered in the <a href="../tooling/">tooling</a> section.</p>

<h3 id="feature-testing">Feature Testing</h3>
<h4 id="star"><img class="emoji" title=":star:" alt=":star:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2b50.png" height="20" width="20" align="absmiddle"></h4>

<p>Post-MVP, some form of feature-testing will be required. We don’t yet have the
experience writing polyfills to know whether <code class="highlighter-rouge">has_feature</code> is the right
primitive building block so we’re not defining it (or something else) until we
gain this experience. In the interim, it’s possible to do a crude feature test
(as people do in JavaScript) by just <code class="highlighter-rouge">eval</code>-ing WebAssembly code and catching
validation errors.</p>

<p>See <a href="../feature-test/">Feature test</a> for a more detailed sketch.</p>

<h2 id="proposals-we-might-consider-in-the-future">Proposals we might consider in the future</h2>

<h3 id="finer-grained-control-over-memory">Finer-grained control over memory</h3>

<p>Provide access to safe OS-provided functionality including:</p>

<ul>
  <li>
<code class="highlighter-rouge">map_file(addr, length, Blob, file-offset)</code>: semantically, this operator
 copies the specified range from <code class="highlighter-rouge">Blob</code> into the range <code class="highlighter-rouge">[addr, addr+length)</code>
 (where <code class="highlighter-rouge">addr+length &lt;= memory_size</code>) but implementations are encouraged
 to <code class="highlighter-rouge">mmap(addr, length, MAP_FIXED | MAP_PRIVATE, fd)</code>
</li>
  <li>
<code class="highlighter-rouge">discard(addr, length)</code>: semantically, this operator zeroes the given range
 but the implementation is encouraged to drop the zeroed physical pages from
 the process’s working set (e.g., by calling <code class="highlighter-rouge">madvise(MADV_DONTNEED)</code> on
 POSIX)</li>
  <li>
<code class="highlighter-rouge">shmem_create(length)</code>: create a memory object that can be simultaneously
shared between multiple linear memories</li>
  <li>
<code class="highlighter-rouge">map_shmem(addr, length, shmem, shmem-offset)</code>: like <code class="highlighter-rouge">map_file</code> except
<code class="highlighter-rouge">MAP_SHARED</code>, which isn’t otherwise valid on read-only Blobs</li>
  <li>
<code class="highlighter-rouge">mprotect(addr, length, prot-flags)</code>: change protection on the range
<code class="highlighter-rouge">[addr, addr+length)</code> (where <code class="highlighter-rouge">addr+length &lt;= memory_size</code>)</li>
  <li>
<code class="highlighter-rouge">decommit(addr, length)</code>: equivalent to <code class="highlighter-rouge">mprotect(addr, length, PROT_NONE)</code>
followed by <code class="highlighter-rouge">discard(addr, length)</code> and potentially more efficient than
performing these operators in sequence.</li>
</ul>

<p>The <code class="highlighter-rouge">addr</code> and <code class="highlighter-rouge">length</code> parameters above would be required to be multiples of
<a href="../semantics/#resizing"><code class="highlighter-rouge">page_size</code></a>.</p>

<p>The <code class="highlighter-rouge">mprotect</code> operator would require hardware memory protection to execute
efficiently and thus may be added as an “optional” feature (requiring a
<a href="../feature-test/">feature test</a> to use). To support efficient execution even when
no hardware memory protection is available, a restricted form of <code class="highlighter-rouge">mprotect</code>
could be added which is declared statically and only protects low memory
(providing the expected fault-on-low-memory behavior of native C/C++ apps).</p>

<p>The above list of functionality mostly covers the set of functionality
provided by the <code class="highlighter-rouge">mmap</code> OS primitive. One significant exception is that <code class="highlighter-rouge">mmap</code>
can allocate noncontiguous virtual address ranges. See the
<a href="../faq/#what-about-mmap">FAQ</a> for rationale.</p>

<h3 id="large-page-support">Large page support</h3>

<p>Some platforms offer support for memory pages as large as 16GiB, which 
can improve  the efficiency of memory management in some situations. WebAssembly
may offer programs the option to specify a larger page size than the <a href="../semantics/#resizing">default</a>.</p>

<h3 id="more-expressive-control-flow">More expressive control flow</h3>

<p>Some types of control flow (especially irreducible and indirect) cannot be
expressed with maximum efficiency in WebAssembly without patterned output by the
relooper and <a href="https://en.wikipedia.org/wiki/Jump_threading">jump-threading</a>
optimizations in the engine. Target uses for more expressive control flow are:</p>

<ul>
  <li>Language interpreters, which often use computed-<code class="highlighter-rouge">goto</code>.</li>
  <li>Functional language support, where guaranteed tail call optimization is
expected for correctness and performance.</li>
</ul>

<p>Options under consideration:</p>

<ul>
  <li>No action, <code class="highlighter-rouge">while</code> and <code class="highlighter-rouge">switch</code> combined with jump-threading are enough.</li>
  <li>Just add <code class="highlighter-rouge">goto</code> (direct and indirect).</li>
  <li>Add new control-flow primitives that address common patterns.</li>
  <li>Add signature-restricted Proper Tail Calls.</li>
  <li>Add proper tail call, expanding upon signature-restricted proper tail calls, and
making it easier to support other languages, especially functional programming
languages.</li>
</ul>

<h3 id="gcdom-integration">GC/DOM Integration</h3>

<p>See <a href="../gc/">GC.md</a>.</p>

<h3 id="linear-memory-bigger-than-4-gib">Linear memory bigger than 4 GiB</h3>

<p>The WebAssembly MVP will support the wasm32 mode of WebAssembly, with linear
memory sizes up to 4 GiB using 32-bit linear memory indices. To support larger
sizes, the wasm64 mode of WebAssembly will be added in the future, supporting
much greater linear memory sizes using 64-bit linear memory indices. wasm32
and wasm64 are both just modes of WebAssembly, to be selected by a flag in
a module header, and don’t imply any semantics differences outside of how
linear memory is handled. Platforms will also have APIs for querying which of
wasm32 and wasm64 are supported.</p>

<p>Of course, the ability to actually allocate this much memory will always be
subject to dynamic resource availability.</p>

<p>It is likely that wasm64 will initially support only 64-bit linear memory
indices, and wasm32 will leave 64-bit linear memory indices unsupported, so
that implementations don’t have to support multiple index sizes in the same
instance. However, operators with 32-bit indices and operators with 64-bit
indices will be given separate names to leave open the possibility of
supporting both in the same instance in the future.</p>

<h3 id="source-maps-integration">Source maps integration</h3>

<ul>
  <li>Add a new source maps <a href="../mvp/#module-structure">module section type</a>.</li>
  <li>Either embed the source maps directly or just a URL from which source maps can
be downloaded.</li>
  <li>Text source maps become intractably large for even moderate-sized compiled
codes, so probably need to define new binary format for source maps.</li>
  <li>Gestate ideas and start discussions at the
<a href="https://github.com/source-map/source-map-rfc/issues">Source Map RFC repository</a>
</li>
</ul>

<h3 id="coroutines">Coroutines</h3>

<p>Coroutines will <a href="http://wg21.link/n4499">eventually be part of C++</a> and is already popular in other
programming languages that WebAssembly will support.</p>

<h3 id="signature-restricted-proper-tail-calls">Signature-restricted Proper Tail Calls</h3>

<p>See the <a href="http://discourse.specifiction.org/t/request-for-comments-add-a-restricted-subset-of-proper-tail-calls-to-asm-js">asm.js RFC</a> for a full description of signature-restricted Proper
Tail Calls (PTC).</p>

<p>Useful properties of signature-restricted PTCs:</p>

<ul>
  <li>In most cases, can be compiled to a single jump.</li>
  <li>Can express indirect <code class="highlighter-rouge">goto</code> via function-pointer calls.</li>
  <li>Can be used as a compile target for languages with unrestricted PTCs; the code
generator can use a stack in the linear memory to effectively implement a custom call
ABI on top of signature-restricted PTCs.</li>
  <li>An engine that wishes to perform aggressive optimization can fuse a graph of
PTCs into a single function.</li>
  <li>To reduce compile time, a code generator can use PTCs to break up ultra-large
functions into smaller functions at low overhead using PTCs.</li>
  <li>
    <p>A compiler can exert some amount of control over register allocation via the
ordering of arguments in the PTC signature.</p>

  </li>
</ul>

<h3 id="general-purpose-proper-tail-calls">General-purpose Proper Tail Calls</h3>

<p>General-purpose Proper Tail Calls would have no signature restrictions, and
therefore be more broadly usable than
<a href="../semantics/#signature-restricted-proper-tail-calls">Signature-restricted Proper Tail Calls</a>,
though there would be some different performance characteristics.</p>

<h3 id="asynchronous-signals">Asynchronous Signals</h3>

<p>TODO</p>

<h3 id="long-simd">“Long SIMD”</h3>

<p>The initial SIMD API will be a “short SIMD” API, centered around fixed-width
128-bit types and explicit SIMD operators. This is quite portable and useful,
but it won’t be able to deliver the full performance capabilities of some of
today’s popular hardware. There is <a href="https://github.com/tc39/ecmascript_simd/issues/180">a proposal in the SIMD.js repository</a> for
a “long SIMD” model which generalizes to wider hardware vector lengths, making
more natural use of advanced features like vector lane predication,
gather/scatter, and so on. Interesting questions to ask of such an model will
include:</p>

<ul>
  <li>How will this model map onto popular modern SIMD hardware architectures?</li>
  <li>What is this model’s relationship to other hardware parallelism features, such
as GPUs and threads with shared memory?</li>
  <li>How will this model be used from higher-level programming languages? For
example, the C++ committee is considering a wide variety of possible
approaches; which of them might be supported by the model?</li>
  <li>What is the relationship to the “short SIMD” API? “None” may be an acceptable
answer, but it’s something to think about.</li>
  <li>What nondeterminism does this model introduce into the overall platform?</li>
  <li>
    <p>What happens when code uses long SIMD on a hardware platform which doesn’t
support it? Reasonable options may include emulating it without the benefit of
hardware acceleration, or indicating a lack of support through feature tests.</p>

  </li>
</ul>

<h3 id="platform-independent-just-in-time-jit-compilation">Platform-independent Just-in-Time (JIT) compilation</h3>

<p>WebAssembly is a new virtual ISA, and as such applications won’t be able to
simply reuse their existing JIT-compiler backends. Applications will instead
have to interface with WebAssembly’s instructions as if they were a new ISA.</p>

<p>Applications expect a wide variety of JIT-compilation capabilities. WebAssembly
should support:</p>

<ul>
  <li>Producing a dynamic library and loading it into the current WebAssembly
module.</li>
  <li>Define lighter-weight mechanisms, such as the ability to add a function to an
existing module.</li>
  <li>Support explicitly patchable constructs within functions to allow for very
fine-grained JIT-compilation. This includes:
    <ul>
      <li>Code patching for polymorphic inline caching;</li>
      <li>Call patching to chain JIT-compiled functions together;</li>
      <li>Temporary halt-insertion within functions, to trap if a function start
executing while a JIT-compiler’s runtime is performing operators
dangerous to that function.</li>
    </ul>
  </li>
  <li>Provide JITs access to profile feedback for their JIT-compiled code.</li>
  <li>Code unloading capabilities, especially in the context of code garbage
collection and defragmentation.</li>
</ul>

<p>WebAssembly’s JIT interface would likely be fairly low-level. However, there
are use cases for higher-level functionality and optimization too. One avenue
for addressing these use cases is a
<a href="../jit-library/">JIT and Optimization library</a>.</p>

<h3 id="multiprocess-support">Multiprocess support</h3>

<ul>
  <li>
<code class="highlighter-rouge">vfork</code>.</li>
  <li>Inter-process communication.</li>
  <li>Inter-process <code class="highlighter-rouge">mmap</code>.</li>
</ul>

<h3 id="trapping-or-non-trapping-strategies">Trapping or non-trapping strategies.</h3>

<p>Presently, when an instruction traps, the program is immediately terminated.
This suits C/C++ code, where trapping conditions indicate Undefined Behavior at
the source level, and it’s also nice for handwritten code, where trapping
conditions typically indicate an instruction being asked to perform outside its
supported range. However, the current facilities do not cover some interesting
use cases:</p>

<ul>
  <li>Not all likely-bug conditions are covered. For example, it would be very nice
to have a signed-integer add which traps on overflow. Such a construct would
add too much overhead on today’s popular hardware architectures to be used in
general, however it may still be useful in some contexts.</li>
  <li>Some higher-level languages define their own semantics for conditions like
division by zero and so on. It’s possible for compilers to add explicit checks
and handle such cases manually, though more direct support from the platform
could have advantages:
    <ul>
      <li>Non-trapping versions of some operators, such as an integer division
instruction that returns zero instead of trapping on division by zero, could
potentially run faster on some platforms.</li>
      <li>The ability to recover gracefully from traps in some way could make many
things possible. Possibly this could involve throwing or possibly by
resuming execution at the trapping instruction with the execution state
altered, if there can be a reasonable way to specify how that should work.</li>
    </ul>
  </li>
</ul>

<h3 id="additional-integer-operators">Additional integer operators</h3>

<ul>
  <li>The following operators can be built from other operators already present,
however in doing so they read at least one non-constant input multiple times,
breaking single-use expression tree formation.
    <ul>
      <li>
<code class="highlighter-rouge">i32.min_s</code>: signed minimum</li>
      <li>
<code class="highlighter-rouge">i32.max_s</code>: signed maximum</li>
      <li>
<code class="highlighter-rouge">i32.min_u</code>: unsigned minimum</li>
      <li>
<code class="highlighter-rouge">i32.max_u</code>: unsigned maximum</li>
      <li>
<code class="highlighter-rouge">i32.sext</code>: sign-agnostic <code class="highlighter-rouge">sext(x, y)</code> is <code class="highlighter-rouge">shr_s(shl(x,y),y)</code>
</li>
      <li>
<code class="highlighter-rouge">i32.abs_s</code>: signed absolute value (traps on <code class="highlighter-rouge">INT32_MIN</code>)</li>
      <li>
<code class="highlighter-rouge">i32.bswap</code>: sign-agnostic reverse bytes (endian conversion)</li>
      <li>
<code class="highlighter-rouge">i32.bswap16</code>: sign-agnostic, <code class="highlighter-rouge">bswap16(x)</code> is <code class="highlighter-rouge">((x&gt;&gt;8)&amp;255)|((x&amp;255)&lt;&lt;8)</code>
</li>
    </ul>
  </li>
  <li>The following operators are just potentially interesting.
    <ul>
      <li>
<code class="highlighter-rouge">i32.clrs</code>: sign-agnostic count leading redundant sign bits (defined for
all values, including 0)</li>
      <li>
<code class="highlighter-rouge">i32.floor_div_s</code>: signed division (result is <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions">floored</a>)</li>
    </ul>
  </li>
  <li>The following 64-bit-only operators are potentially interesting as well.
    <ul>
      <li>
<code class="highlighter-rouge">i64.mor</code>: sign-agnostic <a href="http://mmix.cs.hm.edu/doc/instructions-en.html#MOR">8x8 bit-matrix multiply with or</a>
</li>
      <li>
<code class="highlighter-rouge">i64.mxor</code>: sign-agnostic <a href="http://mmix.cs.hm.edu/doc/instructions-en.html#MXOR">8x8 bit-matrix multiply with xor</a>
</li>
    </ul>
  </li>
</ul>

<h3 id="additional-floating-point-operators">Additional floating point operators</h3>

<ul>
  <li>
<code class="highlighter-rouge">f32.minnum</code>: minimum; if exactly one operand is NaN, returns the other operand</li>
  <li>
<code class="highlighter-rouge">f32.maxnum</code>: maximum; if exactly one operand is NaN, returns the other operand</li>
  <li>
<code class="highlighter-rouge">f32.fma</code>: fused multiply-add (results always conforming to IEEE 754-2008)</li>
  <li>
<code class="highlighter-rouge">f64.minnum</code>: minimum; if exactly one operand is NaN, returns the other operand</li>
  <li>
<code class="highlighter-rouge">f64.maxnum</code>: maximum; if exactly one operand is NaN, returns the other operand</li>
  <li>
<code class="highlighter-rouge">f64.fma</code>: fused multiply-add (results always conforming to IEEE 754-2008)</li>
</ul>

<p><code class="highlighter-rouge">minnum</code> and <code class="highlighter-rouge">maxnum</code> operators would treat <code class="highlighter-rouge">-0.0</code> as being effectively less
than <code class="highlighter-rouge">0.0</code>.</p>

<p>Note that some operators, like <code class="highlighter-rouge">fma</code>, may not be available or may not perform
well on all platforms. These should be guarded by
<a href="../feature-test/">feature tests</a> so that if available, they behave consistently.</p>

<h3 id="floating-point-approximation-operators">Floating point approximation operators</h3>

<ul>
  <li>
<code class="highlighter-rouge">f32.reciprocal_approximation</code>: reciprocal approximation</li>
  <li>
<code class="highlighter-rouge">f64.reciprocal_approximation</code>: reciprocal approximation</li>
  <li>
<code class="highlighter-rouge">f32.reciprocal_sqrt_approximation</code>: reciprocal sqrt approximation</li>
  <li>
<code class="highlighter-rouge">f64.reciprocal_sqrt_approximation</code>: reciprocal sqrt approximation</li>
</ul>

<p>These operators would not required to be fully precise, but the specifics
would need clarification.</p>

<h3 id="16-bit-and-128-bit-floating-point-support">16-bit and 128-bit floating point support</h3>

<p>For 16-bit floating point support, it may make sense to split the feature
into two parts: support for just converting between 16-bit and 32-bit or
64-bit formats possibly folded into load and store operators, and full
support for actual 16-bit arithmetic.</p>

<p>128-bit is an interesting question because hardware support for it is very
rare, so it’s usually going to be implemented with software emulation anyway,
so there’s nothing preventing WebAssembly applications from linking to an
appropriate emulation library and getting similarly performant results.
Emulation libraries would have more flexibility to offer approximation
techniques such as double-double arithmetic. If we standardize 128-bit
floating point in WebAssembly, it will probably be standard IEEE 754-2008
quadruple precision.</p>

<h3 id="full-ieee-754-2008-conformance">Full IEEE 754-2008 conformance</h3>

<p>WebAssembly floating point conforms IEEE 754-2008 in most respects, but there
are a few areas that are
<a href="../semantics/#floating-point-operators">not yet covered</a>.</p>

<p>To support exceptions and alternate rounding modes, one option is to define an
alternate form for each of <code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">sub</code>, <code class="highlighter-rouge">mul</code>, <code class="highlighter-rouge">div</code>, <code class="highlighter-rouge">sqrt</code>, and <code class="highlighter-rouge">fma</code>. These
alternate forms would have extra operands for rounding mode, masked traps, and
old flags, and an extra result for a new flags value. These operators would be
fairly verbose, but it’s expected that their use cases will be specialized. This
approach has the advantage of exposing no global (even if only per-thread)
control and status registers to applications, and to avoid giving the common
operators the possibility of having side effects.</p>

<p>Debugging techniques are also important, but they don’t necessarily need to be
in the spec itself. Implementations are welcome (and encouraged) to support
non-standard execution modes, enabled only from developer tools, such as modes
with alternate rounding, or evaluation of floating point operators at greater
precision, to support <a href="https://www.cs.berkeley.edu/~wkahan/Mindless.pdf">techniques for detecting numerical instability</a>,
or modes using alternate NaN bitpattern rules, to carry diagnostic information
and help developers track down the sources of NaNs.</p>

<p>To help developers find the sources of floating point exceptions,
implementations may wish to provide a mode where NaN values are produced with
payloads containing identifiers helping programmers locate where the NaNs first
appeared. Another option would be to offer another non-standard execution mode,
enabled only from developer tools, that would enable traps on selected floating
point exceptions, however care should be taken, since not all floating point
exceptions indicate bugs.</p>

<h3 id="flushing-subnormal-values-to-zero">Flushing Subnormal Values to Zero</h3>

<p>Many popular CPUs have significant stalls when processing subnormal values,
and support modes where subnormal values are flushed to zero which avoid
these stalls. And, ARMv7 NEON has no support for subnormal values and always
flushes them. A mode where floating point computations have subnormals flushed
to zero in WebAssembly would address these two issues.</p>

<h3 id="integer-overflow-detection">Integer Overflow Detection</h3>

<p>There are two different use cases here, one where the application wishes to
handle overflow locally, and one where it doesn’t.</p>

<p>When the application is prepared to handle overflow locally, it would be useful
to have arithmetic operators which can indicate when overflow occurred. An
example of this is the checked arithmetic builtins available in compilers such
as
<a href="http://clang.llvm.org/docs/LanguageExtensions.html#checked-arithmetic-builtins">clang</a>
and
<a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">GCC</a>.
If WebAssembly is made to support nodes with multiple return values, that could
be used instead of passing a pointer.</p>

<p>There are also several use cases where an application does not wish to handle
overflow locally. One family of examples includes implementing optimized bignum
arithmetic, or optimizing JavaScript Numbers to use int32 operators. Another family
includes compiling code that doesn’t expect overflow to occur, but which wishes
to have overflow detected and reported if it does happen. These use cases would
ideally like to have overflow trap, and to allow them to
<a href="../future-features/#trapping-or-non-trapping-strategies">handle trap specially</a>. Following the rule that explicitly signed and
unsigned operators trap whenever the result value can not be represented in the
result type, it would be possible to add explicitly signed and unsigned versions
of integer <code class="highlighter-rouge">add</code>, <code class="highlighter-rouge">sub</code>, and <code class="highlighter-rouge">mul</code>, which would trap on overflow. The main
reason we haven’t added these already is that they’re not efficient for
general-purpose use on several of today’s popular hardware architectures.</p>

<h3 id="better-feature-testing-support">Better feature testing support</h3>

<p>The <a href="../feature-test/">MVP feature testing situation</a> could be improved by
allowing unknown/unsupported instructions to decode and validate. The runtime
semantics of these unknown instructions could either be to trap or call a
same-signature module-defined polyfill function. This feature could provide a
lighter-weight alternative to load-time polyfilling (approach 2 in
<a href="../feature-test/">FeatureTest.md</a>), especially if the <a href="../binary-encoding/">specific layer</a>
were to be standardized and performed natively such that no user-space translation 
pass was otherwise necessary.</p>

<h3 id="array-globals">Array globals</h3>

<p>If globals are allowed array types, significant portions of memory could be moved out of linear memory which could reduce fragmentation issues. Languages like Fortran which limit aliasing would be one use case. C/C++ compilers could also determine that some global variables never have their address taken.</p>

<h3 id="multiple-return">Multiple Return</h3>

<p>The stack based nature of WebAssembly lends itself to the possibility
of supporting multiple return values from blocks / functions.</p>

<h3 id="multiple-tables-and-memories">Multiple Tables and Memories</h3>

<p>The MVP limits modules to at most one memory and at most one table (the default
ones) and there are only operators for accessing the default table and memory.</p>

<p>After the MVP and after <a href="../gc/">GC reference types</a> have been added, the default
limitation can be relaxed so that any number of tables and memories could be
imported or internally defined and memories/tables could be passed around as
parameters, return values and locals. New variants of <code class="highlighter-rouge">load</code>, <code class="highlighter-rouge">store</code>
and <code class="highlighter-rouge">call_indirect</code> would then be added which took an additional memory/table
reference operand.</p>

<p>To access an imported or internally-defined non-default table or memory, a
new <code class="highlighter-rouge">address_of</code> operator could be added which, given an index immediate,
would return a first-class reference. Beyond tables and memories, this could
also be used for function definitions to get a reference to a function (which,
since opaque, could be implemented as a raw function pointer).</p>

<h3 id="more-table-operators-and-types">More Table Operators and Types</h3>

<p>In the MVP, WebAssembly has limited functionality for operating on 
<a href="../semantics/#table">tables</a> and the host-environment can do much more (e.g.,
see <a href="../js/#webassemblytable-objects">JavaScript’s <code class="highlighter-rouge">WebAssembly.Table</code> API</a>).
It would be useful to be able to do everything from within WebAssembly so, e.g.,
it was possible to write a WebAssembly dynamic loader in WebAssembly. As a
prerequisite, WebAssembly would need first-class support for 
<a href="../gc/">GC references</a> on the stack and in locals. Given that, the following
could be added:</p>

<ul>
  <li>
<code class="highlighter-rouge">get_table</code>/<code class="highlighter-rouge">set_table</code>: get or set the table element at a given dynamic
index; the got/set value would have a GC reference type</li>
  <li>
<code class="highlighter-rouge">grow_table</code>: grow the current table (up to the optional maximum), similar to
<code class="highlighter-rouge">grow_memory</code>
</li>
  <li>
<code class="highlighter-rouge">current_table_length</code>: like <code class="highlighter-rouge">current_memory</code>.</li>
</ul>

<p>Additionally, in the MVP, the only allowed element type of tables is a generic
“anyfunc” type which simply means the element can be called but there is no
static signature validation check. This could be improved by allowing:</p>

<ul>
  <li>functions with a particular signature, allowing wasm generators to use
multiple homogeneously-typed function tables (instead of a single
heterogeneous function table) which eliminates the implied dynamic signature
check of a call to a heterogeneous table;</li>
  <li>any other specific GC reference type, effectively allowing WebAssembly code
to implement a variety of rooting API schemes.</li>
</ul>

<h3 id="memset-and-memcpy-operators">Memset and Memcpy Operators</h3>

<p>Copying and clearing large memory regions is very common, and making these
operations fast is architecture dependent. Although this can be done in the MVP
via <code class="highlighter-rouge">i32.load</code> and <code class="highlighter-rouge">i32.store</code>, this requires more bytes of code and forces VMs
to recognize the loops as well. The following operators can be added to improve
performance:</p>

<ul>
  <li>
<code class="highlighter-rouge">move_memory</code>: Copy data from a source memory region to destination region;
 these regions may overlap: the copy is performed as if the source region was 
 first copied to a temporary buffer, then the temporary buffer is copied to
 the destination region</li>
  <li>
<code class="highlighter-rouge">set_memory</code>: Set all bytes in a memory region to a given byte</li>
</ul>

<p>We expect that WebAssembly producers will use these operations when the region
size is known to be large, and will use loads/stores otherwise.</p>

<p>TODO: determine how these operations interact w/ shared memory.</p>

      </div>
      <div class="col-xs-12 col-lg-3">
        <h6 class="side-title">文档</h6>
        <nav class="side-nav">
        
        
        <a class="side-nav-item" href="/docs/high-level-goals/">WebAssembly High-Level Goals</a>
        
        <a class="side-nav-item" href="/docs/js/">JavaScript API</a>
        
        <a class="side-nav-item" href="/docs/binary-encoding/">Binary Encoding</a>
        
        <a class="side-nav-item" href="/docs/text-format/">Text Format</a>
        
        <a class="side-nav-item" href="/docs/semantics/">Semantics</a>
        
        <a class="side-nav-item" href="/docs/modules/">Modules</a>
        
        <a class="side-nav-item" href="/docs/faq/">FAQ</a>
        
        <a class="side-nav-item" href="/docs/rationale/">Design Rationale</a>
        
        <a class="side-nav-item" href="/docs/mvp/">Minimum Viable Product</a>
        
        <a class="side-nav-item" href="/docs/future-features/">Features to add after the MVP</a>
        
        <a class="side-nav-item" href="/docs/portability/">Portability</a>
        
        <a class="side-nav-item" href="/docs/security/">Security</a>
        
        <a class="side-nav-item" href="/docs/nondeterminism/">Nondeterminism in WebAssembly</a>
        
        <a class="side-nav-item" href="/docs/use-cases/">Use Cases</a>
        
        <a class="side-nav-item" href="/docs/c-and-c++/">Guide for C/C++ developers</a>
        
        <a class="side-nav-item" href="/docs/web/">Web Embedding</a>
        
        <a class="side-nav-item" href="/docs/non-web/">Non-Web Embeddings</a>
        
        <a class="side-nav-item" href="/docs/feature-test/">Feature Test</a>
        
        <a class="side-nav-item" href="/docs/tooling/">Tooling support</a>
        
        <a class="side-nav-item" href="/docs/gc/">GC / DOM / Web API Integration <img class="emoji" title=":unicorn:" alt=":unicorn:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f984.png" height="20" width="20" align="absmiddle"></a>
        
        <a class="side-nav-item" href="/docs/jit-library/">JIT and Optimization Library</a>
        
        <a class="side-nav-item" href="/docs/dynamic-linking/">Dynamic linking</a>
        
        </nav>
      </div>
    </div>
  </div>
</section>
<div style="display:none">
    <script src="https://s19.cnzz.com/z_stat.php?id=1262073419&amp;web_id=1262073419" language="JavaScript"></script>
</div>
</body>
</html>
