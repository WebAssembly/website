<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WebAssembly News</title>
  <link href="https://webassembly.org/"/>
  <link href="https://webassembly.org/feed.xml" rel="self"/>
  <updated>2025-09-17T00:00:00+00:00</updated>
  <id>https://webassembly.org/</id>
  
  <entry>
    <title>A <code>&lt;wasm-compat&gt;</code> custom element</title>
    <author>
      <name>Thomas Steiner</name>
    </author>
    <link href="https://webassembly.org/news/2025-09-17-wasm-compat/"/>
    <id>https://webassembly.org/news/2025-09-17-wasm-compat/</id>
    <updated>2025-09-17T00:00:00+00:00</updated>
    <summary>A &lt;wasm-compat&gt; custom element</summary>
    <content type="html"><![CDATA[<h1 id="a-ltwasm-compatgt-custom-element">A <code>&lt;wasm-compat&gt;</code> custom element</h1>

<p><em>Published on September 17, 2025 by <a href="https://github.com/tomayac">Thomas Steiner</a>.</em></p>

<p>The <a href="https://webassembly.org/features/">Feature Status</a> table on the WebAssembly website shows the various engines’ support statuses in one handy global overview, including the support status in your own browser. That’s fantastic and what most people will usually resort to when they need compatibility information about Wasm features.</p>

<p>For the occasional case where you want to show a feature’s support status for the various Wasm engines in isolation, for example, in the context of an article, this is the custom element <code class="highlighter-rouge">&lt;wasm-compat&gt;</code> that you can use.</p>

<h2 id="installation">Installation</h2>

<p>You can install the custom element from npm, use a CDN like <a href="https://unpkg.com/wasm-compat">unpkg.com</a>, or simply host the <a href="https://raw.githubusercontent.com/WebAssembly/website/refs/heads/main/js/wasm-compat.js">code</a> yourself.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install </span>wasm-compat
</code></pre></div></div>

<h2 id="usage">Usage</h2>

<p>The following code snippet shows you how to use it to display the support status for the <em>JS BigInt to Wasm i64 Integration</em> feature.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- Load the script. Be sure to include `type="module"` attribute. --&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span> <span class="na">src=</span><span class="s">"wasm-compat.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="c">&lt;!-- Style the element according to your needs --&gt;</span>
<span class="nt">&lt;style&gt;</span>
  <span class="nt">wasm-compat</span> <span class="p">{</span>
    <span class="nl">font-family</span><span class="p">:</span> <span class="n">system-ui</span><span class="p">,</span> <span class="nb">sans-serif</span><span class="p">;</span>
    <span class="nl">max-width</span><span class="p">:</span> <span class="m">600px</span><span class="p">;</span>
  <span class="p">}</span>
<span class="nt">&lt;/style&gt;</span>
<span class="c">&lt;!-- Place the custom element anywhere. --&gt;</span>
<span class="nt">&lt;wasm-compat</span> <span class="na">wasm-feature=</span><span class="s">"bigInt"</span><span class="nt">&gt;&lt;/wasm-feature&gt;</span>
</code></pre></div></div>

<p>The value of the <code class="highlighter-rouge">wasm-feature</code> attribute is any of the <code class="highlighter-rouge">$.features</code> (in <a href="https://www.rfc-editor.org/rfc/rfc9535.html">JSONPath</a> notation) keys of the community-maintained <a href="https://github.com/WebAssembly/website/blob/main/features.json#L3"><code class="highlighter-rouge">features.json</code></a> file. For instance, in the case of the <em>JS BigInt to Wasm i64 Integration</em> feature, the key is <code class="highlighter-rouge">bigInt</code>.</p>

<p>For the fun of it, the following section contains the support statuses for all currently documented features. If you prefer, there’s a simple <a href="/js/wasm-compat-test.html">test page</a> available with just one example.</p>

<div id="wasm-compat-container"></div>

<script type="module">
  const data = await fetch('https://raw.githubusercontent.com/WebAssembly/website/main/features.json').then(response => response.json());
  const html = Object.keys(data.features).map(featureId => {
    return `<wasm-compat wasm-feature="${featureId}"></wasm-compat>`;
  }).join('');
  document.querySelector('#wasm-compat-container').innerHTML = html;
</script>

]]></content>
  </entry>
  
  <entry>
    <title>Wasm 3.0 Completed</title>
    <author>
      <name>Andreas Rossberg</name>
    </author>
    <link href="https://webassembly.org/news/2025-09-17-wasm-3.0/"/>
    <id>https://webassembly.org/news/2025-09-17-wasm-3.0/</id>
    <updated>2025-09-17T00:00:00+00:00</updated>
    <summary>Wasm 3.0 Completed</summary>
    <content type="html"><![CDATA[<h1 id="wasm-30-completed">Wasm 3.0 Completed</h1>

<p><em>Published on September 17, 2025 by <a href="https://github.com/rossberg">Andreas Rossberg</a>.</em></p>

<p>Three years ago, <a href="https://webassembly.org/news/2025-03-20-wasm-2.0/">version 2.0</a> of the Wasm standard was (essentially) finished, which brought a number of new features, such as vector instructions, bulk memory operations, multiple return values, and simple reference types.</p>

<p>In the meantime, the Wasm W3C Community Group and Working Group have not been lazy. Today, we are happy to announce the release of Wasm 3.0 as the new “live” standard.</p>

<p><img src="/assets/wasm3_0.png" alt="Title page of the WebAssembly Specification, Release 3.0, 2025-09-17" /></p>

<p>This is a substantially larger update: several big features, some of which have been in the making for six or eight years, finally made it over the finishing line.</p>

<ul>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/memory64/Overview.md"><em>64-bit address space.</em></a> Memories and tables can now be declared to use <code class="highlighter-rouge">i64</code> as their address type instead of just <code class="highlighter-rouge">i32</code>. That expands the available address space of Wasm applications from 4 gigabytes to (theoretically) 16 exabytes, to the extent that physical hardware allows. While the web will necessarily keep enforcing certain limits — on the web, a 64-bit memory is limited to 16 gigabytes — the new flexibility is especially interesting for non-web ecosystems using Wasm, as they can support much, much larger applications and data sets now.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/multi-memory/Overview.md"><em>Multiple memories.</em></a> Contrary to popular belief, Wasm applications were always able to use multiple memory objects — and hence multiple address spaces — simultaneously. However, previously that was only possible by declaring and accessing each of them in separate modules. This gap has been closed, a single module can now declare (define or import) multiple memories and directly access them, including directly copying data between them. This finally allows tools like wasm-merge, which perform “static linking” on two or more Wasm modules by merging them into one, to work for <em>all</em> Wasm modules. It also paves the way for new uses of separate address spaces, e.g., for security (separating private data), for buffering, or for instrumentation.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/gc/Overview.md"><em>Garbage collection.</em></a> In addition to expanding the capabilities of raw linear memories, Wasm also adds support for a new (and separate) form of storage that is automatically managed by the Wasm runtime via a garbage collector. Staying true to the spirit of Wasm as a low-level language, Wasm GC is low-level as well: a compiler targeting Wasm can declare the memory layout of its runtime data structures in terms of struct and array types, plus unboxed tagged integers, whose allocation and lifetime is then handled by Wasm. But that’s it. Everything else, such as engineering suitable representations for source-language values, including implementation details like method tables, remains the responsibility of compilers targeting Wasm. There are no built-in object systems, nor closures or other higher-level constructs — which would inevitably be heavily biased towards specific languages. Instead, Wasm only provides the basic building blocks for representing such constructs and focuses purely on the memory management aspect.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/function-references/Overview.md"><em>Typed references.</em></a> The GC extension is built upon a substantial extension to the Wasm type system, which now supports much richer forms of references. Reference types can now describe the exact shape of the referenced heap value, avoiding additional runtime checks that would otherwise be needed to ensure safety. This more expressive typing mechanism, including subtyping and type recursion, is also available for function references, making it possible to perform safe indirect function calls without any runtime type or bounds check, through the new <code class="highlighter-rouge">call_ref</code> instruction.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/tail-call/Overview.md"><em>Tail calls.</em></a> Tail calls are a variant of function calls that immediately exit the current function, and thereby avoid taking up additional stack space. Tail calls are an important mechanism that is used in various language implementations both in user-visible ways (e.g., in functional languages) and for internal techniques (e.g., to implement stubs). Wasm tail calls are fully general and work for callees both selected statically (by function index) and dynamically (by reference or table).</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/exception-handling/Exceptions.md"><em>Exception handling.</em></a> Exceptions provide a way to locally abort execution, and are a common feature in modern programming languages. Previously, there was no efficient way to compile exception handling to Wasm, and existing compilers typically resorted to convoluted ways of implementing them by escaping to the host language, e.g., JavaScript. This was neither portable nor efficient. Wasm 3.0 hence provides native exception handling within Wasm. Exceptions are defined by declaring exception tags with associated payload data. As one would expect, an exception can be thrown, and selectively be caught by a surrounding handler, based on its tag. Exception handlers are a new form of block instruction that includes a dispatch list of tag/label pairs or catch-all labels to define where to jump when an exception occurs.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/relaxed-simd/Overview.md"><em>Relaxed vector instructions.</em></a> Wasm 2.0 added a large set of vector (SIMD) instructions, but due to differences in hardware, some of these instructions have to do extra work on some platforms to achieve the specified semantics. In order to squeeze out maximum performance, Wasm 3.0 introduces “relaxed” variants of these instructions that are allowed to have implementation-dependent behavior in certain edge cases. This behavior must be selected from a pre-specified set of legal choices.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/profiles/blob/main/proposals/profiles/Overview.md"><em>Deterministic profile.</em></a> To make up for the added semantic fuzziness of relaxed vector instructions, and in order to support settings that demand or need deterministic execution semantics (such as blockchains, or replayable systems), the Wasm standard now specifies a deterministic default behavior for every instruction with otherwise non-deterministic results — currently, this includes floating-point operators and their generated NaN values and the aforementioned relaxed vector instructions. Between platforms choosing to implement this deterministic execution profile, Wasm thereby is fully deterministic, reproducible, and portable.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/spec/blob/wasm-3.0/proposals/annotations/Overview.md"><em>Custom annotation syntax.</em></a> Finally, the Wasm text format has been enriched with generic syntax for placing annotations in Wasm source code. Analogous to custom sections in the binary format, these annotations are not assigned any meaning by the Wasm standard itself, and can be chosen to be ignored by implementations. However, they provide a way to represent the information stored in custom sections in human-readable and writable form, and concrete annotations can be specified by downstream standards.</p>
  </li>
</ul>

<p>In addition to these core features, embeddings of Wasm into JavaScript benefit from a new extension to the JS API:</p>

<ul>
  <li><a href="https://github.com/WebAssembly/js-string-builtins/blob/main/proposals/js-string-builtins/Overview.md"><em>JS string builtins.</em></a> JavaScript string values can already be passed to Wasm as externrefs. Functions from this new primitive library can be imported into a Wasm module to directly access and manipulate such external string values inside Wasm.</li>
</ul>

<p>With these new features, Wasm has much better support for compiling high-level programming languages. Enabled by this, we have seen various new languages popping up to target Wasm, such as <a href="https://github.com/google/j2cl/blob/master/docs/getting-started-j2wasm.md">Java</a>, <a href="https://dune.readthedocs.io/en/stable/wasmoo.html">OCaml</a>, <a href="https://www.scala-js.org/doc/project/webassembly.html">Scala</a>, <a href="https://kotlinlang.org/docs/wasm-overview.html">Kotlin</a>, <a href="https://spritely.institute/hoot/">Scheme</a>, or <a href="https://dart.dev/web/wasm">Dart</a>, all of which use the new GC feature.</p>

<p>On top of all these goodies, Wasm 3.0 also is the first version of the standard that has been produced with the new <a href="https://webassembly.org/news/2025-03-27-spectec/">SpecTec</a> tool chain. We believe that this makes for an even more reliable specification.</p>

<p>Wasm 3.0 is already shipping in most major web browsers, and support in stand-alone engines like Wasmtime is on track to completion as well. The <a href="https://webassembly.org/features/">Wasm feature status</a> page tracks support across engines.</p>
]]></content>
  </entry>
  
  <entry>
    <title>SpecTec has been adopted</title>
    <author>
      <name>Andreas Rossberg</name>
    </author>
    <link href="https://webassembly.org/news/2025-03-27-spectec/"/>
    <id>https://webassembly.org/news/2025-03-27-spectec/</id>
    <updated>2025-03-27T00:00:00+00:00</updated>
    <summary>SpecTec has been adopted</summary>
    <content type="html"><![CDATA[<h1 id="spectec-has-been-adopted">SpecTec has been adopted</h1>

<p><em>Published on March 27, 2025 by
<a href="https://github.com/rossberg">Andreas Rossberg</a>.</em></p>

<p>Two weeks ago, the Wasm Community Group voted to adopt
<a href="https://github.com/Wasm-DSL/spectec/tree/main/spectec">SpecTec</a> for authoring
future editions of the Wasm spec. In this post, I’ll shed some light on what
SpecTec is, what it helps with, and why it takes Wasm to a new level of rigor
and assurance that is unprecedented when it comes to language standards.</p>

<h3 id="formal-language-semantics">Formal language semantics</h3>

<p>One feature that sets Wasm apart from other mainstream programming technologies
is that it comes with a complete formalization: its syntax (binary and text
format), type system (validation), and operational semantics (execution) are
given in self-contained, mathematically precise terms. This formal specification
was not an afterthought, it is an integral part of Wasm’s design process and has
been a normative part of the official language standard from day one. And not
just that: it enabled the <em>soundness</em> of the language — i.e., the fact that it
has no undefined behavior and no runtime type errors can occur — to be
<a href="https://github.com/WasmCert">machine-verified</a> before the first version of the
standard was published.</p>

<p>This was a huge leap forward, because the practical state of language
specifications is basically stuck in the 1960s: most language standards, even
new ones, are still defined by some basic grammar notation for their syntax (and
sometimes not even that), while their semantics is given by a combination of
pretty prose, hidden assumptions, and wishful thinking.</p>

<p>It is hard to avoid ambiguities, contradictions, oversights, and serious bugs in
such an approach. Given that programming languages are the very foundation upon
which all our critical systems are built today, that is a bit scary. And not
quite up to the standard that we came to expect from other mature engineering
disciplines: imagine a suspension bridge built with the methodology of a tree
house, from just pencil drawings and with statics guesstimated as we go.</p>

<p>Fortunately, that gap is more or less a solved problem, at least in principle.
When it comes to scientific papers and text books, programming languages are
routinely defined by a combination of formal techniques developed in the 70s to
90s. In 1990 already,
<a href="https://mitpress.mit.edu/9780262631327/the-definition-of-standard-ml/">The Definition of Standard ML</a>
was published, the first comprehensive formal definition of a general-purpose
programming language of realistic size and scope. (In case you have never heard
of it, ML was a precursor to contemporary functional languages like OCaml and
Haskell, a highly influential academic language that pioneered features like
type inference, type polymorphism (generics), variant types, pattern matching,
and advanced module systems in the early 80s.)</p>

<p>Formalization obviously is tremendously useful for verification and safety, but
it also informs the design process of a language. When you have to carefully
spell out every semantic detail, then “hacky” features tend to materialize
quickly in terms of accidental complexity: a construct that requires ad-hoc
rules, many special cases, or duplication often indicates a design problem. The
feedback loop between design and formalization (and sometimes proofs) hence
helps to produce a simpler and cleaner language, analogous to how implementation
feedback helps with other metrics like performance. In a way, it keeps us honest
as designers.</p>

<h3 id="formal-semantics-in-the-wasm-spec">Formal semantics in the Wasm spec</h3>

<p>With Wasm, we set out to give the state of the art of mainstream language
specification a bit of a push and demonstrate that modern methodologies are
ready for prime time. That is why — in addition to a conventional prose
specification — the Wasm spec also contains a complete (and normative!) formal
specification. In fact, the formal version was written long <em>before</em> the prose,
which was then created by manually transliterating the formal rules into natural
language (for some definition of “natural”). Both formulations complement each
other: where the mathematical formulation is <em>declarative</em> and amenable to
formal methods and quick iteration, the prose formulation is <em>algorithmic</em> and
more accessible to a broader audience of readers.</p>

<p>However, with that we also created a new problem for ourselves: We now have
doubled the work that spec and proposal authors have to do. They have to write
both formulations by hand, a process that is laborious, tedious, and
error-prone. Likewise, the spec editor has to review both, which is equally
tedious and error-prone, especially since neither reStructuredText (Sphinx) nor
LaTeX, — the formats in which the Wasm spec document is written — where designed
with readability or effective diffs in mind. We had to hack around the
shortcomings of both with shell scripts and fragile Sphinx plug-ins, in an
attempt to address some of their more serious problems, like the lack of macros or
layout-sensitive markup rules.</p>

<p>And then there are projects like <a href="https://github.com/WasmCert">WasmCert</a>, which
maintain Wasm’s mechanized soundness proof and other formal methods
developments. They need to translate this semantics into a form readily
understood by a proof assistant. Yet again, this requires a tedious manual
translation to yet another formulation, which, while closely mirroring the
formal rules structurally, is very different syntactically. It has been a
challenge for WasmCert to keep up with the pace of Wasm’s evolution, and both
its mechanizations still only cover (most of)
<a href="../2025-03-20-wasm-2.0/">Wasm 2.0</a>, although many new proposals have
already been merged in the meantime.</p>

<p>We knew that we would eventually get this problem. However, when we first wrote
the Wasm spec back in 2017, there was no better way: we neither had the
technology, nor the resources, nor could we predict future requirements well
enough.</p>

<h3 id="enter-spectec">Enter: SpecTec</h3>

<p>Fast-forward to early 2023, and the stars aligned. At a
<a href="https://www.dagstuhl.de/23101">scientific retreat</a> revolving around Wasm, we
sat together between several groups of researchers and discussed the prospect of
automating parts of the spec-writing and verification process. The idea quickly
grew into designing a domain-specific language (DSL), in which the syntax and
semantics of Wasm can be specified faithfully, and then generating all the
mentioned artifacts from that <em>single source of truth</em>. Lacking better
ideas, we called the DSL
“<a href="https://people.mpi-sws.org/~rossberg/papers/Youn,%20Shin,%20Lee,%20Ryu,%20Breitner,%20Gardner,%20Lindley,%20Pretnar,%20Xiaojia,%20Watt,%20Rossberg%20-%20Bringing%20the%20WebAssembly%20Standard%20up%20to%20Speed%20with%20SpecTec.pdf">SpecTec</a>”.</p>

<p>SpecTec allows
<a href="https://github.com/Wasm-DSL/spectec/blob/main/spectec/doc/Overview.md">expressing the formal rules</a>
of Wasm, almost as they occur in the spec, but in plain, readable ASCII. This
source is then read by the SpecTec implementation, run through a few phases of
parsing, meta-level type checking, and translation, and in the end it can spit
out various outputs:</p>

<ul>
  <li>LaTeX with bells and whistles (like cross-references),</li>
  <li>English prose(!) in Sphinx mark-up,</li>
  <li>Definitions (and possibly lemmata) for the Coq proof assistant,</li>
  <li>A machine-readable AST that other external tools can consume.</li>
</ul>

<p>Viewed from above, SpecTec’s implementation is a compilation pipeline with
multiple internal representations and various backends. The picture below shows
a high-level view of it.</p>

<p><img src="/assets/spectec.png" alt="Diagram showing a formal spec parsed into an intermediate form, then processed by multiple backends to generate docs, code, tests, and proofs, with validation via tests and external tools." /></p>

<p>Generating (algorithmic) natural language prose from a (declarative)
mathematical specification is novel ground. But here are several more goodies
hidden in this diagram.</p>

<p>For one, the prose to be generated is internally represented by an AST called
the “algorithmic language” (AL). And because that is algorithmic, we can
actually execute it. That is what the meta interpreter does: it takes the
description of Wasm’s execution semantics expressed in SpecTec and can “run”
that, e.g., on an actual Wasm module. That way, we can feed the Wasm test suite
to it, and indeed, all applicable tests pass!</p>

<p>This gives a whole new level of assurance (indicated by the yellow chalk arrows in
the picture), that the <em>prose specification</em> that you’ll read in the rendered
document actually is correct and defines what we think it defines! That was not
the case before, and indeed, while developing SpecTec, we discovered numerous
bugs in the hand-crafted prose, and there are probably many more we didn’t spot.
With SpecTec, a wide range of brainless spec bugs becomes impossible, some by
construction, some because we can run it against the test suite. (Caveat: The
meta interpreter currently calls out to the Wasm reference interpreter for
decoding and validation; hence this only tells us something about execution. In
the future, we hope to make it more self-contained.)</p>

<p>In a similar vein, SpecTec can generate definitions representing the Wasm
semantics in <a href="https://coq.inria.fr">Coq/Rocq</a>, the dominant proof assistant in the
area of programming languages. We have started porting the proofs from the
hand-written WasmCert mechanization, and can already handle soundness for the
Wasm 1.0 subset. Scaling to the full language is work in progress.</p>

<p>Once we have proved full soundness this way, we also reach a new level of
assurance regarding the <em>formal specification</em> that you see in the rendered
specification document! This is because both rendered spec and mechanized
definitions are now auto-generated from the same source of truth, and producing
Coq no longer involves a manual translation that is merely based on “eyeball
correspondence” with the original paper rules.</p>

<p>Finally, we have recently started work on another exciting backend for SpecTec:
this one can spit out <code class="highlighter-rouge">.wast</code> test files. So, it is essentially a test fuzzer.
However, it is a fuzzer that is guided by full knowledge of the syntax and
semantics of the language! It understands the typing rules and can predict the
result of executing a piece of code. For example, by just looking at the typing
rule of an instruction, it could systematically generate a complete
combinatorial matrix of micro tests for that instruction, that is, tests for its
behavior under all interesting combinations of types and operands.</p>

<p>Once more, this would take Wasm to a new level of assurance, this time for
implementations. So far, it has been tedious manual work to write tests — or in
some rare cases, manually written scripts that generate some very specific
tests. The coverage of the Wasm test suite, despite not being bad overall, hence
has been “variable” at best. In the future, we hope to get much better coverage
with much less work. And because SpecTec is a generic tool, this ought to be
applicable not just to present features, but also to features that Wasm grows in
the future.</p>

<p>As a final remark, note that SpecTec is <em>not</em> AI. Instead, it is a meticulously
designed translation process. That is very important: when accuracy and rigor is
the goal, then AI with its blackbox behavior and tendency to hallucinate is not
an adequate tool.</p>

<h3 id="whats-next">What’s next?</h3>

<p>Now that the CG has voted to adopt SpecTec, we are working on tweaking a few
remaining rendering issues, and once they are done, we will merge SpecTec — both
the implementation of the tool as well as the actual Wasm spec written with it —
into the main Wasm spec repo. At that point, SpecTec will be automatically
invoked as part of the spec build process.</p>

<p>That is, nothing will change about the overall procedure for building the spec.
Proposal authors, however, no longer need to write much prose or any LaTeX, but
instead extend the SpecTec files and hit a button — well, in the ideal case
anyway; in the beginning, we fully expect road bumps and some missing features
in SpecTec.</p>

<p>All of Wasm 2.0 and all current
<a href="https://github.com/WebAssembly/proposals">Phase 4 and 5 proposals</a> are already
integrated into SpecTec. The official Wasm 3.0 spec will be produced with
SpecTec. You can see a
<a href="https://wasm-dsl.github.io/spectec/">draft of that Wasm 3.0 spec</a> already. For
most part, it looks not too different from the hand-crafted document.</p>

<p>However, not all of the document has been converted to SpecTec yet — we
intentionally designed the tool to allow incremental conversion. Notably, the
sections on numeric primitives and on the text format are currently still
written manually. We plan to convert these over after Wasm 3.0, but in due time.</p>
]]></content>
  </entry>
  
  <entry>
    <title>Wasm 2.0 Completed</title>
    <author>
      <name>Andreas Rossberg</name>
    </author>
    <link href="https://webassembly.org/news/2025-03-20-wasm-2.0/"/>
    <id>https://webassembly.org/news/2025-03-20-wasm-2.0/</id>
    <updated>2025-03-20T00:00:00+00:00</updated>
    <summary>Wasm 2.0 Completed</summary>
    <content type="html"><![CDATA[<h1 id="wasm-20-completed">Wasm 2.0 Completed</h1>

<p><em>Published on March 20, 2025 by <a href="https://github.com/rossberg">Andreas Rossberg</a>.</em></p>

<p>As of last December, release 2.0 of the Wasm specification is “official”!</p>

<p><img src="/assets/wasm2_0.png" alt="Screenshot of W3C site" /></p>

<p>If you have been following the developments of the Wasm standard, then version 2.0 may sound like rather old news to you. And indeed, the Wasm Community and Working Groups had reached consensus and finished the specification in early 2022. All major implementations have been shipping 2.0 for even longer. But for a variety of non-technical reasons, it took a while for it to advance through the W3C process and reach the status of “Candidate Recommendation”.</p>

<p>With the advent of 2.0, the Working Group is switching to a so-called “evergreen” model for future releases. That means that the Candidate Recommendation will be updated in place when we create new versions of the language, without ever technically moving it to the final Recommendation state. For all intents and purposes, the latest <a href="https://www.w3.org/TR/wasm-core-2/">Candidate Recommendation Draft</a> is considered to be the current standard, representing the consensus of the Community Group and Working Group. (If this sounds odd, that’s mostly because the W3C’s document terminology does not quite match this more flexible process, which has recently been adopted by several working groups.)</p>

<p>For the most up-to-date version of the current specification, we recommend looking at the documents hosted on our <a href="https://webassembly.github.io/spec/">GitHub page</a>. This always includes the latest fixes and offers multiple different formats for reading and browsing.</p>

<p>For those who are not following the evolution of Wasm as closely, here is the summary of the additions in version 2.0 of the language:</p>

<ul>
  <li>
    <p><a href="https://github.com/webassembly/simd"><em>Vector instructions</em></a>: With a massive 236 new instructions — more than the total number Wasm had before — it now supports 128-bit wide SIMD (single instruction, multiple data) functionality of contemporary CPUs, like Intel’s SSE or ARM’s SVE. This helps speeding up certain classes of compute-intense applications like audio/video codecs, machine learning, and some cryptography.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/bulk-memory-operations"><em>Bulk memory instructions</em></a>: A set of new instructions allows faster copying and initialization of regions of memory or ranges of tables.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/multi-value"><em>Multi-value results</em></a>: Instructions, blocks, and functions can now return more than one result value, sometimes supporting faster calling conventions and avoiding indirections. In addition, block instructions now also can have inputs, enabling new program transformations.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/reference-types"><em>Reference types</em></a>: References to functions or pointers to external objects (e.g., JavaScript values) become available as opaque first-class values. Tables are repurposed as a general storage for such reference values, and new instructions allow accessing and mutating tables in Wasm code. In addition, modules now may define multiple tables of different types.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions"><em>Non-trapping conversions</em></a>: Additional instructions allow the conversion from float to integer types without the risk of trapping unexpectedly.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/sign-extension-ops"><em>Sign extension instructions</em></a>: A new group of instructions allows directly extending the width of signed integer value. Previously that was only possible when reading from memory.</p>
  </li>
</ul>

<p>It goes without saying that Wasm 2.0 is fully backwards-compatible with 1.0, that is, every valid program remains valid and preserves its behaviour.</p>

<p>In a future post we will take a look at Wasm 3.0, which is already around the corner at this point!</p>
]]></content>
  </entry>
  
  <entry>
    <title>Big News!</title>
    <author>
      <name>Thomas Steiner</name>
    </author>
    <link href="https://webassembly.org/news/2025-03-19-new-news-section/"/>
    <id>https://webassembly.org/news/2025-03-19-new-news-section/</id>
    <updated>2025-03-19T00:00:00+00:00</updated>
    <summary>Big News!</summary>
    <content type="html"><![CDATA[<h1 id="big-news">Big News!</h1>

<p><em>Published on March 19, 2025 by <a href="https://github.com/tomayac">Thomas Steiner</a>.</em></p>

<p>We launched something new 🎉! A <a href="/news/">News</a> section for the WebAssembly homepage!</p>

<p><img src="/assets/wasm-cups.png" alt="Two cups with the WebAssembly logo" /></p>
]]></content>
  </entry>
  
</feed>