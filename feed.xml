<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WebAssembly News</title>
  <link href="https://webassembly.org/"/>
  <link href="https://webassembly.org/feed.xml" rel="self"/>
  <updated>2025-03-27T00:00:00+00:00</updated>
  <id>https://webassembly.org/</id>
  
  <entry>
    <title>SpecTec has been adopted</title>
    <author>
      <name>Andreas Rossberg</name>
    </author>
    <link href="https://webassembly.org/news/2025-03-27-spectec/"/>
    <id>https://webassembly.org/news/2025-03-27-spectec/</id>
    <updated>2025-03-27T00:00:00+00:00</updated>
    <summary>SpecTec has been adopted</summary>
    <content type="html"><![CDATA[<h1 id="spectec-has-been-adopted">SpecTec has been adopted</h1>

<p><em>Published on March 27, 2025 by
<a href="https://github.com/rossberg">Andreas Rossberg</a>.</em></p>

<p>Two weeks ago, the Wasm Community Group voted to adopt
<a href="https://github.com/Wasm-DSL/spectec/tree/main/spectec">SpecTec</a> for authoring
future editions of the Wasm spec. In this post, I’ll shed some light on what
SpecTec is, what it helps with, and why it takes Wasm to a new level of rigor
and assurance that is unprecedented when it comes to language standards.</p>

<h3 id="formal-language-semantics">Formal language semantics</h3>

<p>One feature that sets Wasm apart from other mainstream programming technologies
is that it comes with a complete formalization: its syntax (binary and text
format), type system (validation), and operational semantics (execution) are
given in self-contained, mathematically precise terms. This formal specification
was not an afterthought, it is an integral part of Wasm’s design process and has
been a normative part of the official language standard from day one. And not
just that: it enabled the <em>soundness</em> of the language — i.e., the fact that it
has no undefined behavior and no runtime type errors can occur — to be
<a href="https://github.com/WasmCert">machine-verified</a> before the first version of the
standard was published.</p>

<p>This was a huge leap forward, because the practical state of language
specifications is basically stuck in the 1960s: most language standards, even
new ones, are still defined by some basic grammar notation for their syntax (and
sometimes not even that), while their semantics is given by a combination of
pretty prose, hidden assumptions, and wishful thinking.</p>

<p>It is hard to avoid ambiguities, contradictions, oversights, and serious bugs in
such an approach. Given that programming languages are the very foundation upon
which all our critical systems are built today, that is a bit scary. And not
quite up to the standard that we came to expect from other mature engineering
disciplines: imagine a suspension bridge built with the methodology of a tree
house, from just pencil drawings and with statics guesstimated as we go.</p>

<p>Fortunately, that gap is more or less a solved problem, at least in principle.
When it comes to scientific papers and text books, programming languages are
routinely defined by a combination of formal techniques developed in the 70s to
90s. In 1990 already,
<a href="https://mitpress.mit.edu/9780262631327/the-definition-of-standard-ml/">The Definition of Standard ML</a>
was published, the first comprehensive formal definition of a general-purpose
programming language of realistic size and scope. (In case you have never heard
of it, ML was a precursor to contemporary functional languages like OCaml and
Haskell, a highly influential academic language that pioneered features like
type inference, type polymorphism (generics), variant types, pattern matching,
and advanced module systems in the early 80s.)</p>

<p>Formalization obviously is tremendously useful for verification and safety, but
it also informs the design process of a language. When you have to carefully
spell out every semantic detail, then “hacky” features tend to materialize
quickly in terms of accidental complexity: a construct that requires ad-hoc
rules, many special cases, or duplication often indicates a design problem. The
feedback loop between design and formalization (and sometimes proofs) hence
helps to produce a simpler and cleaner language, analogous to how implementation
feedback helps with other metrics like performance. In a way, it keeps us honest
as designers.</p>

<h3 id="formal-semantics-in-the-wasm-spec">Formal semantics in the Wasm spec</h3>

<p>With Wasm, we set out to give the state of the art of mainstream language
specification a bit of a push and demonstrate that modern methodologies are
ready for prime time. That is why — in addition to a conventional prose
specification — the Wasm spec also contains a complete (and normative!) formal
specification. In fact, the formal version was written long <em>before</em> the prose,
which was then created by manually transliterating the formal rules into natural
language (for some definition of “natural”). Both formulations complement each
other: where the mathematical formulation is <em>declarative</em> and amenable to
formal methods and quick iteration, the prose formulation is <em>algorithmic</em> and
more accessible to a broader audience of readers.</p>

<p>However, with that we also created a new problem for ourselves: We now have
doubled the work that spec and proposal authors have to do. They have to write
both formulations by hand, a process that is laborious, tedious, and
error-prone. Likewise, the spec editor has to review both, which is equally
tedious and error-prone, especially since neither reStructuredText (Sphinx) nor
LaTeX, — the formats in which the Wasm spec document is written — where designed
with readability or effective diffs in mind. We had to hack around the
shortcomings of both with shell scripts and fragile Sphinx plug-ins, in an
attempt to address some of their more serious problems, like the lack of macros or
layout-sensitive markup rules.</p>

<p>And then there are projects like <a href="https://github.com/WasmCert">WasmCert</a>, which
maintain Wasm’s mechanized soundness proof and other formal methods
developments. They need to translate this semantics into a form readily
understood by a proof assistant. Yet again, this requires a tedious manual
translation to yet another formulation, which, while closely mirroring the
formal rules structurally, is very different syntactically. It has been a
challenge for WasmCert to keep up with the pace of Wasm’s evolution, and both
its mechanizations still only cover (most of)
<a href="../2025-03-20-wasm-2.0/">Wasm 2.0</a>, although many new proposals have
already been merged in the meantime.</p>

<p>We knew that we would eventually get this problem. However, when we first wrote
the Wasm spec back in 2017, there was no better way: we neither had the
technology, nor the resources, nor could we predict future requirements well
enough.</p>

<h3 id="enter-spectec">Enter: SpecTec</h3>

<p>Fast-forward to early 2023, and the stars aligned. At a
<a href="https://www.dagstuhl.de/23101">scientific retreat</a> revolving around Wasm, we
sat together between several groups of researchers and discussed the prospect of
automating parts of the spec-writing and verification process. The idea quickly
grew into designing a domain-specific language (DSL), in which the syntax and
semantics of Wasm can be specified faithfully, and then generating all the
mentioned artifacts from that <em>single source of truth</em>. Lacking better
ideas, we called the DSL
“<a href="https://people.mpi-sws.org/~rossberg/papers/Youn,%20Shin,%20Lee,%20Ryu,%20Breitner,%20Gardner,%20Lindley,%20Pretnar,%20Xiaojia,%20Watt,%20Rossberg%20-%20Bringing%20the%20WebAssembly%20Standard%20up%20to%20Speed%20with%20SpecTec.pdf">SpecTec</a>”.</p>

<p>SpecTec allows
<a href="https://github.com/Wasm-DSL/spectec/blob/main/spectec/doc/Overview.md">expressing the formal rules</a>
of Wasm, almost as they occur in the spec, but in plain, readable ASCII. This
source is then read by the SpecTec implementation, run through a few phases of
parsing, meta-level type checking, and translation, and in the end it can spit
out various outputs:</p>

<ul>
  <li>LaTeX with bells and whistles (like cross-references),</li>
  <li>English prose(!) in Sphinx mark-up,</li>
  <li>Definitions (and possibly lemmata) for the Coq proof assistant,</li>
  <li>A machine-readable AST that other external tools can consume.</li>
</ul>

<p>Viewed from above, SpecTec’s implementation is a compilation pipeline with
multiple internal representations and various backends. The picture below shows
a high-level view of it.</p>

<p><img src="/assets/spectec.png" alt="Diagram showing a formal spec parsed into an intermediate form, then processed by multiple backends to generate docs, code, tests, and proofs, with validation via tests and external tools." /></p>

<p>Generating (algorithmic) natural language prose from a (declarative)
mathematical specification is novel ground. But here are several more goodies
hidden in this diagram.</p>

<p>For one, the prose to be generated is internally represented by an AST called
the “algorithmic language” (AL). And because that is algorithmic, we can
actually execute it. That is what the meta interpreter does: it takes the
description of Wasm’s execution semantics expressed in SpecTec and can “run”
that, e.g., on an actual Wasm module. That way, we can feed the Wasm test suite
to it, and indeed, all applicable tests pass!</p>

<p>This gives a whole new level of assurance (indicated by the yellow chalk arrows in
the picture), that the <em>prose specification</em> that you’ll read in the rendered
document actually is correct and defines what we think it defines! That was not
the case before, and indeed, while developing SpecTec, we discovered numerous
bugs in the hand-crafted prose, and there are probably many more we didn’t spot.
With SpecTec, a wide range of brainless spec bugs becomes impossible, some by
construction, some because we can run it against the test suite. (Caveat: The
meta interpreter currently calls out to the Wasm reference interpreter for
decoding and validation; hence this only tells us something about execution. In
the future, we hope to make it more self-contained.)</p>

<p>In a similar vein, SpecTec can generate definitions representing the Wasm
semantics in <a href="https://coq.inria.fr">Coq/Rocq</a>, the dominant proof assistant in the
area of programming languages. We have started porting the proofs from the
hand-written WasmCert mechanization, and can already handle soundness for the
Wasm 1.0 subset. Scaling to the full language is work in progress.</p>

<p>Once we have proved full soundness this way, we also reach a new level of
assurance regarding the <em>formal specification</em> that you see in the rendered
specification document! This is because both rendered spec and mechanized
definitions are now auto-generated from the same source of truth, and producing
Coq no longer involves a manual translation that is merely based on “eyeball
correspondence” with the original paper rules.</p>

<p>Finally, we have recently started work on another exciting backend for SpecTec:
this one can spit out <code class="highlighter-rouge">.wast</code> test files. So, it is essentially a test fuzzer.
However, it is a fuzzer that is guided by full knowledge of the syntax and
semantics of the language! It understands the typing rules and can predict the
result of executing a piece of code. For example, by just looking at the typing
rule of an instruction, it could systematically generate a complete
combinatorial matrix of micro tests for that instruction, that is, tests for its
behavior under all interesting combinations of types and operands.</p>

<p>Once more, this would take Wasm to a new level of assurance, this time for
implementations. So far, it has been tedious manual work to write tests — or in
some rare cases, manually written scripts that generate some very specific
tests. The coverage of the Wasm test suite, despite not being bad overall, hence
has been “variable” at best. In the future, we hope to get much better coverage
with much less work. And because SpecTec is a generic tool, this ought to be
applicable not just to present features, but also to features that Wasm grows in
the future.</p>

<p>As a final remark, note that SpecTec is <em>not</em> AI. Instead, it is a meticulously
designed translation process. That is very important: when accuracy and rigor is
the goal, then AI with its blackbox behavior and tendency to hallucinate is not
an adequate tool.</p>

<h3 id="whats-next">What’s next?</h3>

<p>Now that the CG has voted to adopt SpecTec, we are working on tweaking a few
remaining rendering issues, and once they are done, we will merge SpecTec — both
the implementation of the tool as well as the actual Wasm spec written with it —
into the main Wasm spec repo. At that point, SpecTec will be automatically
invoked as part of the spec build process.</p>

<p>That is, nothing will change about the overall procedure for building the spec.
Proposal authors, however, no longer need to write much prose or any LaTeX, but
instead extend the SpecTec files and hit a button — well, in the ideal case
anyway; in the beginning, we fully expect road bumps and some missing features
in SpecTec.</p>

<p>All of Wasm 2.0 and all current
<a href="https://github.com/WebAssembly/proposals">Phase 4 and 5 proposals</a> are already
integrated into SpecTec. The official Wasm 3.0 spec will be produced with
SpecTec. You can see a
<a href="https://wasm-dsl.github.io/spectec/">draft of that Wasm 3.0 spec</a> already. For
most part, it looks not too different from the hand-crafted document.</p>

<p>However, not all of the document has been converted to SpecTec yet — we
intentionally designed the tool to allow incremental conversion. Notably, the
sections on numeric primitives and on the text format are currently still
written manually. We plan to convert these over after Wasm 3.0, but in due time.</p>
]]></content>
  </entry>
  
  <entry>
    <title>Wasm 2.0 Completed</title>
    <author>
      <name>Andreas Rossberg</name>
    </author>
    <link href="https://webassembly.org/news/2025-03-20-wasm-2.0/"/>
    <id>https://webassembly.org/news/2025-03-20-wasm-2.0/</id>
    <updated>2025-03-20T00:00:00+00:00</updated>
    <summary>Wasm 2.0 Completed</summary>
    <content type="html"><![CDATA[<h1 id="wasm-20-completed">Wasm 2.0 Completed</h1>

<p><em>Published on March 20, 2025 by <a href="https://github.com/rossberg">Andreas Rossberg</a>.</em></p>

<p>As of last December, release 2.0 of the Wasm specification is “official”!</p>

<p><img src="/assets/wasm2_0.png" alt="Screenshot of W3C site" /></p>

<p>If you have been following the developments of the Wasm standard, then version 2.0 may sound like rather old news to you. And indeed, the Wasm Community and Working Groups had reached consensus and finished the specification in early 2022. All major implementations have been shipping 2.0 for even longer. But for a variety of non-technical reasons, it took a while for it to advance through the W3C process and reach the status of “Candidate Recommendation”.</p>

<p>With the advent of 2.0, the Working Group is switching to a so-called “evergreen” model for future releases. That means that the Candidate Recommendation will be updated in place when we create new versions of the language, without ever technically moving it to the final Recommendation state. For all intents and purposes, the latest <a href="https://www.w3.org/TR/wasm-core-2/">Candidate Recommendation Draft</a> is considered to be the current standard, representing the consensus of the Community Group and Working Group. (If this sounds odd, that’s mostly because the W3C’s document terminology does not quite match this more flexible process, which has recently been adopted by several working groups.)</p>

<p>For the most up-to-date version of the current specification, we recommend looking at the documents hosted on our <a href="https://webassembly.github.io/spec/">GitHub page</a>. This always includes the latest fixes and offers multiple different formats for reading and browsing.</p>

<p>For those who are not following the evolution of Wasm as closely, here is the summary of the additions in version 2.0 of the language:</p>

<ul>
  <li>
    <p><a href="https://github.com/webassembly/simd"><em>Vector instructions</em></a>: With a massive 236 new instructions — more than the total number Wasm had before — it now supports 128-bit wide SIMD (single instruction, multiple data) functionality of contemporary CPUs, like Intel’s SSE or ARM’s SVE. This helps speeding up certain classes of compute-intense applications like audio/video codecs, machine learning, and some cryptography.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/bulk-memory-operations"><em>Bulk memory instructions</em></a>: A set of new instructions allows faster copying and initialization of regions of memory or ranges of tables.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/multi-value"><em>Multi-value results</em></a>: Instructions, blocks, and functions can now return more than one result value, sometimes supporting faster calling conventions and avoiding indirections. In addition, block instructions now also can have inputs, enabling new program transformations.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/reference-types"><em>Reference types</em></a>: References to functions or pointers to external objects (e.g., JavaScript values) become available as opaque first-class values. Tables are repurposed as a general storage for such reference values, and new instructions allow accessing and mutating tables in Wasm code. In addition, modules now may define multiple tables of different types.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/nontrapping-float-to-int-conversions"><em>Non-trapping conversions</em></a>: Additional instructions allow the conversion from float to integer types without the risk of trapping unexpectedly.</p>
  </li>
  <li>
    <p><a href="https://github.com/WebAssembly/sign-extension-ops"><em>Sign extension instructions</em></a>: A new group of instructions allows directly extending the width of signed integer value. Previously that was only possible when reading from memory.</p>
  </li>
</ul>

<p>It goes without saying that Wasm 2.0 is fully backwards-compatible with 1.0, that is, every valid program remains valid and preserves its behaviour.</p>

<p>In a future post we will take a look at Wasm 3.0, which is already around the corner at this point!</p>
]]></content>
  </entry>
  
  <entry>
    <title>Big News!</title>
    <author>
      <name>Thomas Steiner</name>
    </author>
    <link href="https://webassembly.org/news/2025-03-19-new-news-section/"/>
    <id>https://webassembly.org/news/2025-03-19-new-news-section/</id>
    <updated>2025-03-19T00:00:00+00:00</updated>
    <summary>Big News!</summary>
    <content type="html"><![CDATA[<h1 id="big-news">Big News!</h1>

<p><em>Published on March 19, 2025 by <a href="https://github.com/tomayac">Thomas Steiner</a>.</em></p>

<p>We launched something new 🎉! A <a href="/news/">News</a> section for the WebAssembly homepage!</p>

<p><img src="/assets/wasm-cups.png" alt="Two cups with the WebAssembly logo" /></p>
]]></content>
  </entry>
  
</feed>